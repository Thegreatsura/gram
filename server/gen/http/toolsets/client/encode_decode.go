// Code generated by goa v3.20.1, DO NOT EDIT.
//
// toolsets HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/design

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	toolsets "github.com/speakeasy-api/gram/gen/toolsets"
	goahttp "goa.design/goa/v3/http"
)

// BuildCreateToolsetRequest instantiates a HTTP request object with method and
// path set to call the "toolsets" service "createToolset" endpoint
func (c *Client) BuildCreateToolsetRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateToolsetToolsetsPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("toolsets", "createToolset", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateToolsetRequest returns an encoder for requests sent to the
// toolsets createToolset server.
func EncodeCreateToolsetRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*toolsets.CreateToolsetPayload)
		if !ok {
			return goahttp.ErrInvalidType("toolsets", "createToolset", "*toolsets.CreateToolsetPayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		body := NewCreateToolsetRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("toolsets", "createToolset", err)
		}
		return nil
	}
}

// DecodeCreateToolsetResponse returns a decoder for responses returned by the
// toolsets createToolset endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeCreateToolsetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CreateToolsetResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("toolsets", "createToolset", err)
			}
			err = ValidateCreateToolsetResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("toolsets", "createToolset", err)
			}
			res := NewCreateToolsetToolsetDetailsOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("toolsets", "createToolset", resp.StatusCode, string(body))
		}
	}
}

// BuildListToolsetsRequest instantiates a HTTP request object with method and
// path set to call the "toolsets" service "listToolsets" endpoint
func (c *Client) BuildListToolsetsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListToolsetsToolsetsPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("toolsets", "listToolsets", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListToolsetsRequest returns an encoder for requests sent to the
// toolsets listToolsets server.
func EncodeListToolsetsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*toolsets.ListToolsetsPayload)
		if !ok {
			return goahttp.ErrInvalidType("toolsets", "listToolsets", "*toolsets.ListToolsetsPayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		return nil
	}
}

// DecodeListToolsetsResponse returns a decoder for responses returned by the
// toolsets listToolsets endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeListToolsetsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListToolsetsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("toolsets", "listToolsets", err)
			}
			err = ValidateListToolsetsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("toolsets", "listToolsets", err)
			}
			res := NewListToolsetsResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("toolsets", "listToolsets", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateToolsetRequest instantiates a HTTP request object with method and
// path set to call the "toolsets" service "updateToolset" endpoint
func (c *Client) BuildUpdateToolsetRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		slug string
	)
	{
		p, ok := v.(*toolsets.UpdateToolsetPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("toolsets", "updateToolset", "*toolsets.UpdateToolsetPayload", v)
		}
		slug = p.Slug
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateToolsetToolsetsPath(slug)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("toolsets", "updateToolset", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateToolsetRequest returns an encoder for requests sent to the
// toolsets updateToolset server.
func EncodeUpdateToolsetRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*toolsets.UpdateToolsetPayload)
		if !ok {
			return goahttp.ErrInvalidType("toolsets", "updateToolset", "*toolsets.UpdateToolsetPayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		body := NewUpdateToolsetRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("toolsets", "updateToolset", err)
		}
		return nil
	}
}

// DecodeUpdateToolsetResponse returns a decoder for responses returned by the
// toolsets updateToolset endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeUpdateToolsetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateToolsetResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("toolsets", "updateToolset", err)
			}
			err = ValidateUpdateToolsetResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("toolsets", "updateToolset", err)
			}
			res := NewUpdateToolsetToolsetDetailsOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("toolsets", "updateToolset", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteToolsetRequest instantiates a HTTP request object with method and
// path set to call the "toolsets" service "deleteToolset" endpoint
func (c *Client) BuildDeleteToolsetRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		slug string
	)
	{
		p, ok := v.(*toolsets.DeleteToolsetPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("toolsets", "deleteToolset", "*toolsets.DeleteToolsetPayload", v)
		}
		slug = p.Slug
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteToolsetToolsetsPath(slug)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("toolsets", "deleteToolset", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteToolsetRequest returns an encoder for requests sent to the
// toolsets deleteToolset server.
func EncodeDeleteToolsetRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*toolsets.DeleteToolsetPayload)
		if !ok {
			return goahttp.ErrInvalidType("toolsets", "deleteToolset", "*toolsets.DeleteToolsetPayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		return nil
	}
}

// DecodeDeleteToolsetResponse returns a decoder for responses returned by the
// toolsets deleteToolset endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeDeleteToolsetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("toolsets", "deleteToolset", resp.StatusCode, string(body))
		}
	}
}

// BuildGetToolsetDetailsRequest instantiates a HTTP request object with method
// and path set to call the "toolsets" service "getToolsetDetails" endpoint
func (c *Client) BuildGetToolsetDetailsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		slug string
	)
	{
		p, ok := v.(*toolsets.GetToolsetDetailsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("toolsets", "getToolsetDetails", "*toolsets.GetToolsetDetailsPayload", v)
		}
		slug = p.Slug
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetToolsetDetailsToolsetsPath(slug)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("toolsets", "getToolsetDetails", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetToolsetDetailsRequest returns an encoder for requests sent to the
// toolsets getToolsetDetails server.
func EncodeGetToolsetDetailsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*toolsets.GetToolsetDetailsPayload)
		if !ok {
			return goahttp.ErrInvalidType("toolsets", "getToolsetDetails", "*toolsets.GetToolsetDetailsPayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		return nil
	}
}

// DecodeGetToolsetDetailsResponse returns a decoder for responses returned by
// the toolsets getToolsetDetails endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeGetToolsetDetailsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetToolsetDetailsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("toolsets", "getToolsetDetails", err)
			}
			err = ValidateGetToolsetDetailsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("toolsets", "getToolsetDetails", err)
			}
			res := NewGetToolsetDetailsToolsetDetailsOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("toolsets", "getToolsetDetails", resp.StatusCode, string(body))
		}
	}
}

// unmarshalHTTPToolDefinitionResponseBodyToToolsetsHTTPToolDefinition builds a
// value of type *toolsets.HTTPToolDefinition from a value of type
// *HTTPToolDefinitionResponseBody.
func unmarshalHTTPToolDefinitionResponseBodyToToolsetsHTTPToolDefinition(v *HTTPToolDefinitionResponseBody) *toolsets.HTTPToolDefinition {
	res := &toolsets.HTTPToolDefinition{
		ID:                  *v.ID,
		ProjectID:           *v.ProjectID,
		DeploymentID:        *v.DeploymentID,
		Openapiv3DocumentID: v.Openapiv3DocumentID,
		Name:                *v.Name,
		Summary:             *v.Summary,
		Description:         *v.Description,
		Openapiv3Operation:  v.Openapiv3Operation,
		Security:            v.Security,
		HTTPMethod:          *v.HTTPMethod,
		Path:                *v.Path,
		SchemaVersion:       v.SchemaVersion,
		Schema:              *v.Schema,
		CreatedAt:           *v.CreatedAt,
		UpdatedAt:           *v.UpdatedAt,
	}
	res.Tags = make([]string, len(v.Tags))
	for i, val := range v.Tags {
		res.Tags[i] = val
	}

	return res
}

// unmarshalToolsetDetailsResponseBodyToToolsetsToolsetDetails builds a value
// of type *toolsets.ToolsetDetails from a value of type
// *ToolsetDetailsResponseBody.
func unmarshalToolsetDetailsResponseBodyToToolsetsToolsetDetails(v *ToolsetDetailsResponseBody) *toolsets.ToolsetDetails {
	res := &toolsets.ToolsetDetails{
		ID:                     *v.ID,
		ProjectID:              *v.ProjectID,
		OrganizationID:         *v.OrganizationID,
		Name:                   *v.Name,
		Slug:                   *v.Slug,
		Description:            v.Description,
		DefaultEnvironmentSlug: v.DefaultEnvironmentSlug,
		CreatedAt:              *v.CreatedAt,
		UpdatedAt:              *v.UpdatedAt,
	}
	if v.RelevantEnvironmentVariables != nil {
		res.RelevantEnvironmentVariables = make([]string, len(v.RelevantEnvironmentVariables))
		for i, val := range v.RelevantEnvironmentVariables {
			res.RelevantEnvironmentVariables[i] = val
		}
	}
	res.HTTPTools = make([]*toolsets.HTTPToolDefinition, len(v.HTTPTools))
	for i, val := range v.HTTPTools {
		res.HTTPTools[i] = unmarshalHTTPToolDefinitionResponseBodyToToolsetsHTTPToolDefinition(val)
	}

	return res
}
