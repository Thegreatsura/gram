// Code generated by goa v3.20.1, DO NOT EDIT.
//
// packages HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/design

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strings"

	packages "github.com/speakeasy-api/gram/gen/packages"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeCreatePackageResponse returns an encoder for responses returned by the
// packages createPackage endpoint.
func EncodeCreatePackageResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*packages.CreatePackageResult)
		enc := encoder(ctx, w)
		body := NewCreatePackageResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreatePackageRequest returns a decoder for requests sent to the
// packages createPackage endpoint.
func DecodeCreatePackageRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreatePackageRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreatePackageRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			sessionToken     *string
			projectSlugInput *string
		)
		sessionTokenRaw := r.Header.Get("Gram-Session")
		if sessionTokenRaw != "" {
			sessionToken = &sessionTokenRaw
		}
		projectSlugInputRaw := r.Header.Get("Gram-Project")
		if projectSlugInputRaw != "" {
			projectSlugInput = &projectSlugInputRaw
		}
		payload := NewCreatePackagePayload(&body, sessionToken, projectSlugInput)
		if payload.SessionToken != nil {
			if strings.Contains(*payload.SessionToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.SessionToken, " ", 2)[1]
				payload.SessionToken = &cred
			}
		}
		if payload.ProjectSlugInput != nil {
			if strings.Contains(*payload.ProjectSlugInput, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ProjectSlugInput, " ", 2)[1]
				payload.ProjectSlugInput = &cred
			}
		}

		return payload, nil
	}
}

// EncodeListVersionsResponse returns an encoder for responses returned by the
// packages listVersions endpoint.
func EncodeListVersionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*packages.ListVersionsResult)
		enc := encoder(ctx, w)
		body := NewListVersionsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListVersionsRequest returns a decoder for requests sent to the
// packages listVersions endpoint.
func DecodeListVersionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			name             string
			sessionToken     *string
			projectSlugInput *string
			err              error
		)
		name = r.URL.Query().Get("name")
		if name == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("name", "query string"))
		}
		sessionTokenRaw := r.Header.Get("Gram-Session")
		if sessionTokenRaw != "" {
			sessionToken = &sessionTokenRaw
		}
		projectSlugInputRaw := r.Header.Get("Gram-Project")
		if projectSlugInputRaw != "" {
			projectSlugInput = &projectSlugInputRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewListVersionsPayload(name, sessionToken, projectSlugInput)
		if payload.SessionToken != nil {
			if strings.Contains(*payload.SessionToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.SessionToken, " ", 2)[1]
				payload.SessionToken = &cred
			}
		}
		if payload.ProjectSlugInput != nil {
			if strings.Contains(*payload.ProjectSlugInput, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ProjectSlugInput, " ", 2)[1]
				payload.ProjectSlugInput = &cred
			}
		}

		return payload, nil
	}
}

// EncodePublishResponse returns an encoder for responses returned by the
// packages publish endpoint.
func EncodePublishResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*packages.PublishPackageResult)
		enc := encoder(ctx, w)
		body := NewPublishResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodePublishRequest returns a decoder for requests sent to the packages
// publish endpoint.
func DecodePublishRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body PublishRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidatePublishRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			sessionToken     *string
			projectSlugInput *string
		)
		sessionTokenRaw := r.Header.Get("Gram-Session")
		if sessionTokenRaw != "" {
			sessionToken = &sessionTokenRaw
		}
		projectSlugInputRaw := r.Header.Get("Gram-Project")
		if projectSlugInputRaw != "" {
			projectSlugInput = &projectSlugInputRaw
		}
		payload := NewPublishPayload(&body, sessionToken, projectSlugInput)
		if payload.SessionToken != nil {
			if strings.Contains(*payload.SessionToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.SessionToken, " ", 2)[1]
				payload.SessionToken = &cred
			}
		}
		if payload.ProjectSlugInput != nil {
			if strings.Contains(*payload.ProjectSlugInput, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ProjectSlugInput, " ", 2)[1]
				payload.ProjectSlugInput = &cred
			}
		}

		return payload, nil
	}
}

// marshalPackagesPackageToPackageResponseBody builds a value of type
// *PackageResponseBody from a value of type *packages.Package.
func marshalPackagesPackageToPackageResponseBody(v *packages.Package) *PackageResponseBody {
	res := &PackageResponseBody{
		ID:             v.ID,
		ProjectID:      v.ProjectID,
		OrganizationID: v.OrganizationID,
		Name:           v.Name,
		Title:          v.Title,
		Summary:        v.Summary,
		LatestVersion:  v.LatestVersion,
		CreatedAt:      v.CreatedAt,
		UpdatedAt:      v.UpdatedAt,
		DeletedAt:      v.DeletedAt,
	}
	if v.Keywords != nil {
		res.Keywords = make([]string, len(v.Keywords))
		for i, val := range v.Keywords {
			res.Keywords[i] = val
		}
	}

	return res
}

// marshalPackagesPackageVersionToPackageVersionResponseBody builds a value of
// type *PackageVersionResponseBody from a value of type
// *packages.PackageVersion.
func marshalPackagesPackageVersionToPackageVersionResponseBody(v *packages.PackageVersion) *PackageVersionResponseBody {
	res := &PackageVersionResponseBody{
		ID:           v.ID,
		PackageID:    v.PackageID,
		DeploymentID: v.DeploymentID,
		Visibility:   v.Visibility,
		Semver:       v.Semver,
		CreatedAt:    v.CreatedAt,
	}

	return res
}
