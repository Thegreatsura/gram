// Code generated by goa v3.20.1, DO NOT EDIT.
//
// packages HTTP server types
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/design

package server

import (
	"unicode/utf8"

	packages "github.com/speakeasy-api/gram/gen/packages"
	goa "goa.design/goa/v3/pkg"
)

// CreatePackageRequestBody is the type of the "packages" service
// "createPackage" endpoint HTTP request body.
type CreatePackageRequestBody struct {
	// The name of the package
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The title of the package
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The summary of the package
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// The keywords of the package
	Keywords []string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
}

// PublishRequestBody is the type of the "packages" service "publish" endpoint
// HTTP request body.
type PublishRequestBody struct {
	// The name of the package
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The new semantic version of the package to publish
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	// The deployment ID to associate with the package version
	DeploymentID *string `form:"deployment_id,omitempty" json:"deployment_id,omitempty" xml:"deployment_id,omitempty"`
	// The visibility of the package version
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
}

// CreatePackageResponseBody is the type of the "packages" service
// "createPackage" endpoint HTTP response body.
type CreatePackageResponseBody struct {
	// The newly created package
	Package *PackageResponseBody `form:"package" json:"package" xml:"package"`
}

// ListVersionsResponseBody is the type of the "packages" service
// "listVersions" endpoint HTTP response body.
type ListVersionsResponseBody struct {
	Package  *PackageResponseBody          `form:"package" json:"package" xml:"package"`
	Versions []*PackageVersionResponseBody `form:"versions" json:"versions" xml:"versions"`
}

// PublishResponseBody is the type of the "packages" service "publish" endpoint
// HTTP response body.
type PublishResponseBody struct {
	// The published package
	Package *PackageResponseBody `form:"package" json:"package" xml:"package"`
	// The published package version
	Version *PackageVersionResponseBody `form:"version" json:"version" xml:"version"`
}

// PackageResponseBody is used to define fields on response body types.
type PackageResponseBody struct {
	// The ID of the package
	ID string `form:"id" json:"id" xml:"id"`
	// The ID of the project that owns the package
	ProjectID string `form:"project_id" json:"project_id" xml:"project_id"`
	// The ID of the organization that owns the package
	OrganizationID string `form:"organization_id" json:"organization_id" xml:"organization_id"`
	// The name of the package
	Name string `form:"name" json:"name" xml:"name"`
	// The title of the package
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The summary of the package
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
	// The keywords of the package
	Keywords []string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// The latest version of the package
	LatestVersion *string `form:"latest_version,omitempty" json:"latest_version,omitempty" xml:"latest_version,omitempty"`
	// The creation date of the package
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// The last update date of the package
	UpdatedAt string `form:"updated_at" json:"updated_at" xml:"updated_at"`
	// The deletion date of the package
	DeletedAt *string `form:"deleted_at,omitempty" json:"deleted_at,omitempty" xml:"deleted_at,omitempty"`
}

// PackageVersionResponseBody is used to define fields on response body types.
type PackageVersionResponseBody struct {
	// The ID of the package version
	ID string `form:"id" json:"id" xml:"id"`
	// The ID of the package that the version belongs to
	PackageID string `form:"package_id" json:"package_id" xml:"package_id"`
	// The ID of the deployment that the version belongs to
	DeploymentID string `form:"deployment_id" json:"deployment_id" xml:"deployment_id"`
	// The visibility of the package version
	Visibility string `form:"visibility" json:"visibility" xml:"visibility"`
	// The semantic version value
	Semver string `form:"semver" json:"semver" xml:"semver"`
	// The creation date of the package version
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
}

// NewCreatePackageResponseBody builds the HTTP response body from the result
// of the "createPackage" endpoint of the "packages" service.
func NewCreatePackageResponseBody(res *packages.CreatePackageResult) *CreatePackageResponseBody {
	body := &CreatePackageResponseBody{}
	if res.Package != nil {
		body.Package = marshalPackagesPackageToPackageResponseBody(res.Package)
	}
	return body
}

// NewListVersionsResponseBody builds the HTTP response body from the result of
// the "listVersions" endpoint of the "packages" service.
func NewListVersionsResponseBody(res *packages.ListVersionsResult) *ListVersionsResponseBody {
	body := &ListVersionsResponseBody{}
	if res.Package != nil {
		body.Package = marshalPackagesPackageToPackageResponseBody(res.Package)
	}
	if res.Versions != nil {
		body.Versions = make([]*PackageVersionResponseBody, len(res.Versions))
		for i, val := range res.Versions {
			body.Versions[i] = marshalPackagesPackageVersionToPackageVersionResponseBody(val)
		}
	} else {
		body.Versions = []*PackageVersionResponseBody{}
	}
	return body
}

// NewPublishResponseBody builds the HTTP response body from the result of the
// "publish" endpoint of the "packages" service.
func NewPublishResponseBody(res *packages.PublishPackageResult) *PublishResponseBody {
	body := &PublishResponseBody{}
	if res.Package != nil {
		body.Package = marshalPackagesPackageToPackageResponseBody(res.Package)
	}
	if res.Version != nil {
		body.Version = marshalPackagesPackageVersionToPackageVersionResponseBody(res.Version)
	}
	return body
}

// NewCreatePackagePayload builds a packages service createPackage endpoint
// payload.
func NewCreatePackagePayload(body *CreatePackageRequestBody, sessionToken *string, projectSlugInput *string) *packages.CreatePackagePayload {
	v := &packages.CreatePackagePayload{
		Name:    *body.Name,
		Title:   body.Title,
		Summary: body.Summary,
	}
	if body.Keywords != nil {
		v.Keywords = make([]string, len(body.Keywords))
		for i, val := range body.Keywords {
			v.Keywords[i] = val
		}
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v
}

// NewListVersionsPayload builds a packages service listVersions endpoint
// payload.
func NewListVersionsPayload(name string, sessionToken *string, projectSlugInput *string) *packages.ListVersionsPayload {
	v := &packages.ListVersionsPayload{}
	v.Name = name
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v
}

// NewPublishPayload builds a packages service publish endpoint payload.
func NewPublishPayload(body *PublishRequestBody, sessionToken *string, projectSlugInput *string) *packages.PublishPayload {
	v := &packages.PublishPayload{
		Name:         *body.Name,
		Version:      *body.Version,
		DeploymentID: *body.DeploymentID,
		Visibility:   *body.Visibility,
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v
}

// ValidateCreatePackageRequestBody runs the validations defined on
// CreatePackageRequestBody
func ValidateCreatePackageRequestBody(body *CreatePackageRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Name != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", *body.Name, "^[a-z]+(?:[a-z0-9_-]*[a-z0-9])?$"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 100, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 100, false))
		}
	}
	if body.Summary != nil {
		if utf8.RuneCountInString(*body.Summary) > 80 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.summary", *body.Summary, utf8.RuneCountInString(*body.Summary), 80, false))
		}
	}
	if len(body.Keywords) > 5 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", body.Keywords, len(body.Keywords), 5, false))
	}
	return
}

// ValidatePublishRequestBody runs the validations defined on PublishRequestBody
func ValidatePublishRequestBody(body *PublishRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Version == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("version", "body"))
	}
	if body.DeploymentID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("deployment_id", "body"))
	}
	if body.Visibility == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("visibility", "body"))
	}
	if body.Visibility != nil {
		if !(*body.Visibility == "public" || *body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
		}
	}
	return
}
