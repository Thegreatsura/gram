// Code generated by goa v3.20.1, DO NOT EDIT.
//
// packages HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/design

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	packages "github.com/speakeasy-api/gram/gen/packages"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreatePackagePayload builds the payload for the packages createPackage
// endpoint from CLI flags.
func BuildCreatePackagePayload(packagesCreatePackageBody string, packagesCreatePackageSessionToken string, packagesCreatePackageProjectSlugInput string) (*packages.CreatePackagePayload, error) {
	var err error
	var body CreatePackageRequestBody
	{
		err = json.Unmarshal([]byte(packagesCreatePackageBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"image_asset_id\": \"t76\",\n      \"keywords\": [\n         \"Voluptatum nemo eum ex necessitatibus.\",\n         \"Nostrum labore.\",\n         \"Eaque perspiciatis fuga excepturi alias.\"\n      ],\n      \"name\": \"o19\",\n      \"summary\": \"zmb\",\n      \"title\": \"t9w\",\n      \"url\": \"bjo\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", body.Name, "^[a-z]+(?:[a-z0-9_-]*[a-z0-9])?$"))
		if utf8.RuneCountInString(body.Name) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 100, false))
		}
		if utf8.RuneCountInString(body.Title) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 100, false))
		}
		if utf8.RuneCountInString(body.Summary) > 80 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.summary", body.Summary, utf8.RuneCountInString(body.Summary), 80, false))
		}
		if body.URL != nil {
			if utf8.RuneCountInString(*body.URL) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.url", *body.URL, utf8.RuneCountInString(*body.URL), 100, false))
			}
		}
		if len(body.Keywords) > 5 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", body.Keywords, len(body.Keywords), 5, false))
		}
		if body.ImageAssetID != nil {
			if utf8.RuneCountInString(*body.ImageAssetID) > 50 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.image_asset_id", *body.ImageAssetID, utf8.RuneCountInString(*body.ImageAssetID), 50, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if packagesCreatePackageSessionToken != "" {
			sessionToken = &packagesCreatePackageSessionToken
		}
	}
	var projectSlugInput *string
	{
		if packagesCreatePackageProjectSlugInput != "" {
			projectSlugInput = &packagesCreatePackageProjectSlugInput
		}
	}
	v := &packages.CreatePackagePayload{
		Name:         body.Name,
		Title:        body.Title,
		Summary:      body.Summary,
		URL:          body.URL,
		ImageAssetID: body.ImageAssetID,
	}
	if body.Keywords != nil {
		v.Keywords = make([]string, len(body.Keywords))
		for i, val := range body.Keywords {
			v.Keywords[i] = val
		}
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildUpdatePackagePayload builds the payload for the packages updatePackage
// endpoint from CLI flags.
func BuildUpdatePackagePayload(packagesUpdatePackageBody string, packagesUpdatePackageSessionToken string, packagesUpdatePackageProjectSlugInput string) (*packages.UpdatePackagePayload, error) {
	var err error
	var body UpdatePackageRequestBody
	{
		err = json.Unmarshal([]byte(packagesUpdatePackageBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"0j2\",\n      \"image_asset_id\": \"r17\",\n      \"keywords\": [\n         \"Ipsum est aut qui omnis.\",\n         \"Accusamus sint.\",\n         \"Perspiciatis amet.\"\n      ],\n      \"summary\": \"9qa\",\n      \"title\": \"kko\",\n      \"url\": \"wwd\"\n   }'")
		}
		if utf8.RuneCountInString(body.ID) > 50 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", body.ID, utf8.RuneCountInString(body.ID), 50, false))
		}
		if body.Title != nil {
			if utf8.RuneCountInString(*body.Title) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 100, false))
			}
		}
		if body.Summary != nil {
			if utf8.RuneCountInString(*body.Summary) > 80 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.summary", *body.Summary, utf8.RuneCountInString(*body.Summary), 80, false))
			}
		}
		if body.URL != nil {
			if utf8.RuneCountInString(*body.URL) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.url", *body.URL, utf8.RuneCountInString(*body.URL), 100, false))
			}
		}
		if len(body.Keywords) > 5 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", body.Keywords, len(body.Keywords), 5, false))
		}
		if body.ImageAssetID != nil {
			if utf8.RuneCountInString(*body.ImageAssetID) > 50 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.image_asset_id", *body.ImageAssetID, utf8.RuneCountInString(*body.ImageAssetID), 50, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if packagesUpdatePackageSessionToken != "" {
			sessionToken = &packagesUpdatePackageSessionToken
		}
	}
	var projectSlugInput *string
	{
		if packagesUpdatePackageProjectSlugInput != "" {
			projectSlugInput = &packagesUpdatePackageProjectSlugInput
		}
	}
	v := &packages.UpdatePackagePayload{
		ID:           body.ID,
		Title:        body.Title,
		Summary:      body.Summary,
		URL:          body.URL,
		ImageAssetID: body.ImageAssetID,
	}
	if body.Keywords != nil {
		v.Keywords = make([]string, len(body.Keywords))
		for i, val := range body.Keywords {
			v.Keywords[i] = val
		}
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListVersionsPayload builds the payload for the packages listVersions
// endpoint from CLI flags.
func BuildListVersionsPayload(packagesListVersionsName string, packagesListVersionsSessionToken string, packagesListVersionsProjectSlugInput string) (*packages.ListVersionsPayload, error) {
	var name string
	{
		name = packagesListVersionsName
	}
	var sessionToken *string
	{
		if packagesListVersionsSessionToken != "" {
			sessionToken = &packagesListVersionsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if packagesListVersionsProjectSlugInput != "" {
			projectSlugInput = &packagesListVersionsProjectSlugInput
		}
	}
	v := &packages.ListVersionsPayload{}
	v.Name = name
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildPublishPayload builds the payload for the packages publish endpoint
// from CLI flags.
func BuildPublishPayload(packagesPublishBody string, packagesPublishSessionToken string, packagesPublishProjectSlugInput string) (*packages.PublishPayload, error) {
	var err error
	var body PublishRequestBody
	{
		err = json.Unmarshal([]byte(packagesPublishBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"deployment_id\": \"Expedita ipsam corporis.\",\n      \"name\": \"Omnis ducimus voluptas aut consequuntur.\",\n      \"version\": \"Deserunt est tenetur debitis quo.\",\n      \"visibility\": \"public\"\n   }'")
		}
		if !(body.Visibility == "public" || body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", body.Visibility, []any{"public", "private"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if packagesPublishSessionToken != "" {
			sessionToken = &packagesPublishSessionToken
		}
	}
	var projectSlugInput *string
	{
		if packagesPublishProjectSlugInput != "" {
			projectSlugInput = &packagesPublishProjectSlugInput
		}
	}
	v := &packages.PublishPayload{
		Name:         body.Name,
		Version:      body.Version,
		DeploymentID: body.DeploymentID,
		Visibility:   body.Visibility,
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
