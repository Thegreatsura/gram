// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const cloneDeployment = `-- name: CloneDeployment :one
INSERT INTO deployments (
  cloned_from
  , idempotency_key
  , user_id
  , organization_id
  , project_id
  , github_repo
  , github_pr
  , external_id
  , external_url
)
SELECT 
  current.id
  , gen_random_uuid()
  , current.user_id
  , current.organization_id
  , current.project_id
  , current.github_repo
  , current.github_pr
  , current.external_id
  , current.external_url
FROM deployments as current
WHERE current.id = $1 AND current.project_id = $2
RETURNING id
`

type CloneDeploymentParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) CloneDeployment(ctx context.Context, arg CloneDeploymentParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, cloneDeployment, arg.ID, arg.ProjectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const cloneDeploymentOpenAPIv3Assets = `-- name: CloneDeploymentOpenAPIv3Assets :many
INSERT INTO deployments_openapiv3_assets (
  deployment_id
  , asset_id
  , name
  , slug
)
SELECT 
  $1
  , current.asset_id
  , current.name
  , current.slug
FROM deployments_openapiv3_assets as current
WHERE current.deployment_id = $2
  AND current.id != ANY ($3)
RETURNING id
`

type CloneDeploymentOpenAPIv3AssetsParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedIds          []uuid.UUID
}

func (q *Queries) CloneDeploymentOpenAPIv3Assets(ctx context.Context, arg CloneDeploymentOpenAPIv3AssetsParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentOpenAPIv3Assets, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cloneDeploymentPackages = `-- name: CloneDeploymentPackages :many
INSERT INTO deployments_packages (
  deployment_id
  , package_id
  , version_id
)
SELECT 
  $1
  , current.package_id
  , current.version_id
FROM deployments_packages as current
WHERE current.deployment_id = $2
  AND current.id != ANY ($3)
RETURNING id, package_id, version_id
`

type CloneDeploymentPackagesParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedIds          []uuid.UUID
}

type CloneDeploymentPackagesRow struct {
	ID        uuid.UUID
	PackageID uuid.UUID
	VersionID uuid.UUID
}

func (q *Queries) CloneDeploymentPackages(ctx context.Context, arg CloneDeploymentPackagesParams) ([]CloneDeploymentPackagesRow, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentPackages, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CloneDeploymentPackagesRow
	for rows.Next() {
		var i CloneDeploymentPackagesRow
		if err := rows.Scan(&i.ID, &i.PackageID, &i.VersionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createDeployment = `-- name: CreateDeployment :execresult
INSERT INTO deployments (
  idempotency_key
  , user_id
  , organization_id
  , project_id
  , github_repo
  , github_pr
  , external_id
  , external_url
) VALUES (
  $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
)
ON CONFLICT (project_id, idempotency_key) DO NOTHING
`

type CreateDeploymentParams struct {
	IdempotencyKey string
	UserID         string
	OrganizationID string
	ProjectID      uuid.UUID
	GithubRepo     pgtype.Text
	GithubPr       pgtype.Text
	ExternalID     pgtype.Text
	ExternalUrl    pgtype.Text
}

func (q *Queries) CreateDeployment(ctx context.Context, arg CreateDeploymentParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createDeployment,
		arg.IdempotencyKey,
		arg.UserID,
		arg.OrganizationID,
		arg.ProjectID,
		arg.GithubRepo,
		arg.GithubPr,
		arg.ExternalID,
		arg.ExternalUrl,
	)
}

const createHTTPSecurity = `-- name: CreateHTTPSecurity :one
INSERT INTO http_security (
    key
  , deployment_id
  , type
  , name
  , in_placement
  , scheme
  , bearer_format
  , env_variables
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
)
RETURNING id, key, deployment_id, type, name, in_placement, scheme, bearer_format, env_variables, created_at, updated_at, deleted_at, deleted
`

type CreateHTTPSecurityParams struct {
	Key          string
	DeploymentID uuid.UUID
	Type         pgtype.Text
	Name         string
	InPlacement  string
	Scheme       pgtype.Text
	BearerFormat pgtype.Text
	EnvVariables []string
}

func (q *Queries) CreateHTTPSecurity(ctx context.Context, arg CreateHTTPSecurityParams) (HttpSecurity, error) {
	row := q.db.QueryRow(ctx, createHTTPSecurity,
		arg.Key,
		arg.DeploymentID,
		arg.Type,
		arg.Name,
		arg.InPlacement,
		arg.Scheme,
		arg.BearerFormat,
		arg.EnvVariables,
	)
	var i HttpSecurity
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DeploymentID,
		&i.Type,
		&i.Name,
		&i.InPlacement,
		&i.Scheme,
		&i.BearerFormat,
		&i.EnvVariables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createOpenAPIv3ToolDefinition = `-- name: CreateOpenAPIv3ToolDefinition :one
INSERT INTO http_tool_definitions (
    project_id
  , deployment_id
  , openapiv3_document_id
  , name
  , openapiv3_operation
  , summary
  , description
  , tags
  , security
  , http_method
  , path
  , schema_version
  , schema
  , header_settings
  , query_settings
  , path_settings
  , server_env_var
  , default_server_url
  , request_content_type
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , $11
  , $12
  , $13
  , $14
  , $15
  , $16
  , $17
  , $18
  , $19
)
RETURNING id, project_id, deployment_id, openapiv3_document_id, name, summary, description, openapiv3_operation, tags, server_env_var, default_server_url, security, http_method, path, schema_version, schema, header_settings, query_settings, path_settings, request_content_type, created_at, updated_at, deleted_at, deleted
`

type CreateOpenAPIv3ToolDefinitionParams struct {
	ProjectID           uuid.UUID
	DeploymentID        uuid.UUID
	Openapiv3DocumentID uuid.NullUUID
	Name                string
	Openapiv3Operation  pgtype.Text
	Summary             string
	Description         string
	Tags                []string
	Security            []byte
	HttpMethod          string
	Path                string
	SchemaVersion       string
	Schema              []byte
	HeaderSettings      []byte
	QuerySettings       []byte
	PathSettings        []byte
	ServerEnvVar        string
	DefaultServerUrl    pgtype.Text
	RequestContentType  pgtype.Text
}

func (q *Queries) CreateOpenAPIv3ToolDefinition(ctx context.Context, arg CreateOpenAPIv3ToolDefinitionParams) (HttpToolDefinition, error) {
	row := q.db.QueryRow(ctx, createOpenAPIv3ToolDefinition,
		arg.ProjectID,
		arg.DeploymentID,
		arg.Openapiv3DocumentID,
		arg.Name,
		arg.Openapiv3Operation,
		arg.Summary,
		arg.Description,
		arg.Tags,
		arg.Security,
		arg.HttpMethod,
		arg.Path,
		arg.SchemaVersion,
		arg.Schema,
		arg.HeaderSettings,
		arg.QuerySettings,
		arg.PathSettings,
		arg.ServerEnvVar,
		arg.DefaultServerUrl,
		arg.RequestContentType,
	)
	var i HttpToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.DeploymentID,
		&i.Openapiv3DocumentID,
		&i.Name,
		&i.Summary,
		&i.Description,
		&i.Openapiv3Operation,
		&i.Tags,
		&i.ServerEnvVar,
		&i.DefaultServerUrl,
		&i.Security,
		&i.HttpMethod,
		&i.Path,
		&i.SchemaVersion,
		&i.Schema,
		&i.HeaderSettings,
		&i.QuerySettings,
		&i.PathSettings,
		&i.RequestContentType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const describeDeploymentPackages = `-- name: DescribeDeploymentPackages :many
SELECT 
  deployments_packages.id as deployment_package_id
  , packages.name as package_name
  , package_versions.id, package_versions.package_id, package_versions.deployment_id, package_versions.visibility, package_versions.major, package_versions.minor, package_versions.patch, package_versions.prerelease, package_versions.build, package_versions.created_at, package_versions.updated_at, package_versions.deleted_at, package_versions.deleted
FROM deployments_packages
INNER JOIN packages ON deployments_packages.package_id = packages.id
INNER JOIN package_versions ON deployments_packages.version_id = package_versions.id
WHERE deployments_packages.deployment_id = $1
`

type DescribeDeploymentPackagesRow struct {
	DeploymentPackageID uuid.UUID
	PackageName         string
	PackageVersion      PackageVersion
}

func (q *Queries) DescribeDeploymentPackages(ctx context.Context, deploymentID uuid.UUID) ([]DescribeDeploymentPackagesRow, error) {
	rows, err := q.db.Query(ctx, describeDeploymentPackages, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DescribeDeploymentPackagesRow
	for rows.Next() {
		var i DescribeDeploymentPackagesRow
		if err := rows.Scan(
			&i.DeploymentPackageID,
			&i.PackageName,
			&i.PackageVersion.ID,
			&i.PackageVersion.PackageID,
			&i.PackageVersion.DeploymentID,
			&i.PackageVersion.Visibility,
			&i.PackageVersion.Major,
			&i.PackageVersion.Minor,
			&i.PackageVersion.Patch,
			&i.PackageVersion.Prerelease,
			&i.PackageVersion.Build,
			&i.PackageVersion.CreatedAt,
			&i.PackageVersion.UpdatedAt,
			&i.PackageVersion.DeletedAt,
			&i.PackageVersion.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeployment = `-- name: GetDeployment :one
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $1
    ORDER BY seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE deployments.id = $1 AND deployments.project_id = $2
`

type GetDeploymentParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetDeploymentRow struct {
	Deployment Deployment
	Status     string
}

func (q *Queries) GetDeployment(ctx context.Context, arg GetDeploymentParams) (GetDeploymentRow, error) {
	row := q.db.QueryRow(ctx, getDeployment, arg.ID, arg.ProjectID)
	var i GetDeploymentRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.Seq,
		&i.Deployment.UserID,
		&i.Deployment.ProjectID,
		&i.Deployment.OrganizationID,
		&i.Deployment.IdempotencyKey,
		&i.Deployment.ClonedFrom,
		&i.Deployment.GithubRepo,
		&i.Deployment.GithubPr,
		&i.Deployment.GithubSha,
		&i.Deployment.ExternalID,
		&i.Deployment.ExternalUrl,
		&i.Deployment.CreatedAt,
		&i.Deployment.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getDeploymentByIdempotencyKey = `-- name: GetDeploymentByIdempotencyKey :one
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    INNER JOIN deployments ON deployment_statuses.deployment_id = deployments.id
    WHERE deployments.idempotency_key = $1
    ORDER BY deployment_statuses.seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE deployments.idempotency_key = $1
 AND deployments.project_id = $2
`

type GetDeploymentByIdempotencyKeyParams struct {
	IdempotencyKey string
	ProjectID      uuid.UUID
}

type GetDeploymentByIdempotencyKeyRow struct {
	Deployment Deployment
	Status     string
}

func (q *Queries) GetDeploymentByIdempotencyKey(ctx context.Context, arg GetDeploymentByIdempotencyKeyParams) (GetDeploymentByIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, getDeploymentByIdempotencyKey, arg.IdempotencyKey, arg.ProjectID)
	var i GetDeploymentByIdempotencyKeyRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.Seq,
		&i.Deployment.UserID,
		&i.Deployment.ProjectID,
		&i.Deployment.OrganizationID,
		&i.Deployment.IdempotencyKey,
		&i.Deployment.ClonedFrom,
		&i.Deployment.GithubRepo,
		&i.Deployment.GithubPr,
		&i.Deployment.GithubSha,
		&i.Deployment.ExternalID,
		&i.Deployment.ExternalUrl,
		&i.Deployment.CreatedAt,
		&i.Deployment.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getDeploymentOpenAPIv3 = `-- name: GetDeploymentOpenAPIv3 :many
SELECT id, deployment_id, asset_id, name, slug
FROM deployments_openapiv3_assets
WHERE deployment_id = $1
`

func (q *Queries) GetDeploymentOpenAPIv3(ctx context.Context, deploymentID uuid.UUID) ([]DeploymentsOpenapiv3Asset, error) {
	rows, err := q.db.Query(ctx, getDeploymentOpenAPIv3, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeploymentsOpenapiv3Asset
	for rows.Next() {
		var i DeploymentsOpenapiv3Asset
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.AssetID,
			&i.Name,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentWithAssets = `-- name: GetDeploymentWithAssets :many
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $1
    ORDER BY seq DESC
    LIMIT 1
)
SELECT
  deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at,
  coalesce(latest_status.status, 'unknown') as status,
  deployments_openapiv3_assets.id as deployments_openapiv3_asset_id,
  deployments_openapiv3_assets.asset_id as deployments_openapiv3_asset_store_id,
  deployments_openapiv3_assets.name as deployments_openapiv3_asset_name,
  deployments_openapiv3_assets.slug as deployments_openapiv3_asset_slug,
  deployments_packages.id as deployment_package_id,
  packages.name as package_name,
  package_versions.major as package_version_major,
  package_versions.minor as package_version_minor,
  package_versions.patch as package_version_patch,
  package_versions.prerelease as package_version_prerelease,
  package_versions.build as package_version_build
FROM deployments
LEFT JOIN deployments_openapiv3_assets ON deployments.id = deployments_openapiv3_assets.deployment_id
LEFT JOIN deployments_packages ON deployments.id = deployments_packages.deployment_id
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
LEFT JOIN packages ON deployments_packages.package_id = packages.id
LEFT JOIN package_versions ON deployments_packages.version_id = package_versions.id
WHERE deployments.id = $1 AND deployments.project_id = $2
`

type GetDeploymentWithAssetsParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetDeploymentWithAssetsRow struct {
	Deployment                       Deployment
	Status                           string
	DeploymentsOpenapiv3AssetID      uuid.NullUUID
	DeploymentsOpenapiv3AssetStoreID uuid.NullUUID
	DeploymentsOpenapiv3AssetName    pgtype.Text
	DeploymentsOpenapiv3AssetSlug    pgtype.Text
	DeploymentPackageID              uuid.NullUUID
	PackageName                      pgtype.Text
	PackageVersionMajor              pgtype.Int2
	PackageVersionMinor              pgtype.Int2
	PackageVersionPatch              pgtype.Int2
	PackageVersionPrerelease         pgtype.Text
	PackageVersionBuild              pgtype.Text
}

func (q *Queries) GetDeploymentWithAssets(ctx context.Context, arg GetDeploymentWithAssetsParams) ([]GetDeploymentWithAssetsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentWithAssets, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentWithAssetsRow
	for rows.Next() {
		var i GetDeploymentWithAssetsRow
		if err := rows.Scan(
			&i.Deployment.ID,
			&i.Deployment.Seq,
			&i.Deployment.UserID,
			&i.Deployment.ProjectID,
			&i.Deployment.OrganizationID,
			&i.Deployment.IdempotencyKey,
			&i.Deployment.ClonedFrom,
			&i.Deployment.GithubRepo,
			&i.Deployment.GithubPr,
			&i.Deployment.GithubSha,
			&i.Deployment.ExternalID,
			&i.Deployment.ExternalUrl,
			&i.Deployment.CreatedAt,
			&i.Deployment.UpdatedAt,
			&i.Status,
			&i.DeploymentsOpenapiv3AssetID,
			&i.DeploymentsOpenapiv3AssetStoreID,
			&i.DeploymentsOpenapiv3AssetName,
			&i.DeploymentsOpenapiv3AssetSlug,
			&i.DeploymentPackageID,
			&i.PackageName,
			&i.PackageVersionMajor,
			&i.PackageVersionMinor,
			&i.PackageVersionPatch,
			&i.PackageVersionPrerelease,
			&i.PackageVersionBuild,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestDeploymentID = `-- name: GetLatestDeploymentID :one
SELECT id
FROM deployments
WHERE project_id = $1
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetLatestDeploymentID(ctx context.Context, projectID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getLatestDeploymentID, projectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const listDeployments = `-- name: ListDeployments :many
SELECT 
  d.id,
  d.user_id,
  d.created_at,
  COUNT(doa.id) as asset_count
FROM deployments d
LEFT JOIN deployments_openapiv3_assets doa ON d.id = doa.deployment_id
WHERE
  d.project_id = $1
  AND d.id <= CASE 
    WHEN $2::uuid IS NOT NULL THEN $2::uuid
    ELSE (SELECT id FROM deployments WHERE project_id = $1 ORDER BY id DESC LIMIT 1)
  END
GROUP BY d.id
ORDER BY d.id DESC
LIMIT 51
`

type ListDeploymentsParams struct {
	ProjectID uuid.UUID
	Cursor    uuid.NullUUID
}

type ListDeploymentsRow struct {
	ID         uuid.UUID
	UserID     string
	CreatedAt  pgtype.Timestamptz
	AssetCount int64
}

func (q *Queries) ListDeployments(ctx context.Context, arg ListDeploymentsParams) ([]ListDeploymentsRow, error) {
	rows, err := q.db.Query(ctx, listDeployments, arg.ProjectID, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentsRow
	for rows.Next() {
		var i ListDeploymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.AssetCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logDeploymentEvent = `-- name: LogDeploymentEvent :exec
INSERT INTO deployment_logs (deployment_id, project_id, event, message)
VALUES ($1, $2, $3, $4)
`

type LogDeploymentEventParams struct {
	DeploymentID uuid.UUID
	ProjectID    uuid.UUID
	Event        string
	Message      string
}

func (q *Queries) LogDeploymentEvent(ctx context.Context, arg LogDeploymentEventParams) error {
	_, err := q.db.Exec(ctx, logDeploymentEvent,
		arg.DeploymentID,
		arg.ProjectID,
		arg.Event,
		arg.Message,
	)
	return err
}

const transitionDeployment = `-- name: TransitionDeployment :one
WITH status AS (
  INSERT INTO deployment_statuses (deployment_id , status)
  VALUES ($1, $2)
  RETURNING id, status
), 
log AS (
  INSERT INTO deployment_logs (deployment_id, project_id, event, message)
  VALUES ($1, $3, $4, $5)
  RETURNING id
)
SELECT status.id as status_id, status.status as status, log.id as log_id
FROM status, log
`

type TransitionDeploymentParams struct {
	DeploymentID uuid.UUID
	Status       string
	ProjectID    uuid.UUID
	Event        string
	Message      string
}

type TransitionDeploymentRow struct {
	StatusID uuid.UUID
	Status   string
	LogID    uuid.UUID
}

func (q *Queries) TransitionDeployment(ctx context.Context, arg TransitionDeploymentParams) (TransitionDeploymentRow, error) {
	row := q.db.QueryRow(ctx, transitionDeployment,
		arg.DeploymentID,
		arg.Status,
		arg.ProjectID,
		arg.Event,
		arg.Message,
	)
	var i TransitionDeploymentRow
	err := row.Scan(&i.StatusID, &i.Status, &i.LogID)
	return i, err
}

const upsertDeploymentOpenAPIv3Asset = `-- name: UpsertDeploymentOpenAPIv3Asset :one
INSERT INTO deployments_openapiv3_assets (
  deployment_id,
  asset_id,
  name,
  slug
) VALUES (
  $1,
  $2,
  $3,
  $4
)
ON CONFLICT (deployment_id, slug) DO UPDATE
SET
  asset_id = EXCLUDED.asset_id,
  name = EXCLUDED.name
RETURNING id, asset_id, name, slug
`

type UpsertDeploymentOpenAPIv3AssetParams struct {
	DeploymentID uuid.UUID
	AssetID      uuid.UUID
	Name         string
	Slug         string
}

type UpsertDeploymentOpenAPIv3AssetRow struct {
	ID      uuid.UUID
	AssetID uuid.UUID
	Name    string
	Slug    string
}

func (q *Queries) UpsertDeploymentOpenAPIv3Asset(ctx context.Context, arg UpsertDeploymentOpenAPIv3AssetParams) (UpsertDeploymentOpenAPIv3AssetRow, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentOpenAPIv3Asset,
		arg.DeploymentID,
		arg.AssetID,
		arg.Name,
		arg.Slug,
	)
	var i UpsertDeploymentOpenAPIv3AssetRow
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.Name,
		&i.Slug,
	)
	return i, err
}

const upsertDeploymentPackage = `-- name: UpsertDeploymentPackage :one
INSERT INTO deployments_packages (
  deployment_id
  , package_id
  , version_id
) VALUES (
  $1,
  $2,
  $3
)
ON CONFLICT (deployment_id, package_id) DO UPDATE
SET
  version_id = EXCLUDED.version_id
RETURNING id
`

type UpsertDeploymentPackageParams struct {
	DeploymentID uuid.UUID
	PackageID    uuid.UUID
	VersionID    uuid.UUID
}

func (q *Queries) UpsertDeploymentPackage(ctx context.Context, arg UpsertDeploymentPackageParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentPackage, arg.DeploymentID, arg.PackageID, arg.VersionID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
