// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addDeploymentOpenAPIv3Asset = `-- name: AddDeploymentOpenAPIv3Asset :one
INSERT INTO deployments_openapiv3_assets (
  deployment_id
  , asset_id
  , name
  , slug
) VALUES (
  $1,
  $2,
  $3,
  $4
)
ON CONFLICT (deployment_id, slug) DO NOTHING
RETURNING id, asset_id, name, slug
`

type AddDeploymentOpenAPIv3AssetParams struct {
	DeploymentID uuid.UUID
	AssetID      uuid.UUID
	Name         string
	Slug         string
}

type AddDeploymentOpenAPIv3AssetRow struct {
	ID      uuid.UUID
	AssetID uuid.UUID
	Name    string
	Slug    string
}

func (q *Queries) AddDeploymentOpenAPIv3Asset(ctx context.Context, arg AddDeploymentOpenAPIv3AssetParams) (AddDeploymentOpenAPIv3AssetRow, error) {
	row := q.db.QueryRow(ctx, addDeploymentOpenAPIv3Asset,
		arg.DeploymentID,
		arg.AssetID,
		arg.Name,
		arg.Slug,
	)
	var i AddDeploymentOpenAPIv3AssetRow
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.Name,
		&i.Slug,
	)
	return i, err
}

const createDeployment = `-- name: CreateDeployment :execresult
INSERT INTO deployments (
  idempotency_key
  , user_id
  , organization_id
  , project_id
  , github_repo
  , github_pr
  , external_id
  , external_url
) VALUES (
  $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
)
ON CONFLICT (project_id, idempotency_key) DO NOTHING
`

type CreateDeploymentParams struct {
	IdempotencyKey string
	UserID         string
	OrganizationID string
	ProjectID      uuid.UUID
	GithubRepo     pgtype.Text
	GithubPr       pgtype.Text
	ExternalID     pgtype.Text
	ExternalUrl    pgtype.Text
}

func (q *Queries) CreateDeployment(ctx context.Context, arg CreateDeploymentParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createDeployment,
		arg.IdempotencyKey,
		arg.UserID,
		arg.OrganizationID,
		arg.ProjectID,
		arg.GithubRepo,
		arg.GithubPr,
		arg.ExternalID,
		arg.ExternalUrl,
	)
}

const createHTTPSecurity = `-- name: CreateHTTPSecurity :one
INSERT INTO http_security (
    key
  , deployment_id
  , type
  , name
  , in_placement
  , scheme
  , bearer_format
  , env_variables
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
)
RETURNING id, key, deployment_id, type, name, in_placement, scheme, bearer_format, env_variables, created_at, updated_at, deleted_at, deleted
`

type CreateHTTPSecurityParams struct {
	Key          string
	DeploymentID uuid.UUID
	Type         string
	Name         string
	InPlacement  string
	Scheme       pgtype.Text
	BearerFormat pgtype.Text
	EnvVariables []string
}

func (q *Queries) CreateHTTPSecurity(ctx context.Context, arg CreateHTTPSecurityParams) (HttpSecurity, error) {
	row := q.db.QueryRow(ctx, createHTTPSecurity,
		arg.Key,
		arg.DeploymentID,
		arg.Type,
		arg.Name,
		arg.InPlacement,
		arg.Scheme,
		arg.BearerFormat,
		arg.EnvVariables,
	)
	var i HttpSecurity
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DeploymentID,
		&i.Type,
		&i.Name,
		&i.InPlacement,
		&i.Scheme,
		&i.BearerFormat,
		&i.EnvVariables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createOpenAPIv3ToolDefinition = `-- name: CreateOpenAPIv3ToolDefinition :one
INSERT INTO http_tool_definitions (
    project_id
  , deployment_id
  , openapiv3_document_id
  , name
  , openapiv3_operation
  , summary
  , description
  , tags
  , security
  , http_method
  , path
  , schema_version
  , schema
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , $11
  , $12
  , $13
)
RETURNING id, project_id, deployment_id, openapiv3_document_id, name, summary, description, openapiv3_operation, tags, server_env_var, security, http_method, path, schema_version, schema, created_at, updated_at, deleted_at, deleted
`

type CreateOpenAPIv3ToolDefinitionParams struct {
	ProjectID           uuid.UUID
	DeploymentID        uuid.UUID
	Openapiv3DocumentID uuid.NullUUID
	Name                string
	Openapiv3Operation  pgtype.Text
	Summary             string
	Description         string
	Tags                []string
	Security            []byte
	HttpMethod          string
	Path                string
	SchemaVersion       string
	Schema              []byte
}

func (q *Queries) CreateOpenAPIv3ToolDefinition(ctx context.Context, arg CreateOpenAPIv3ToolDefinitionParams) (HttpToolDefinition, error) {
	row := q.db.QueryRow(ctx, createOpenAPIv3ToolDefinition,
		arg.ProjectID,
		arg.DeploymentID,
		arg.Openapiv3DocumentID,
		arg.Name,
		arg.Openapiv3Operation,
		arg.Summary,
		arg.Description,
		arg.Tags,
		arg.Security,
		arg.HttpMethod,
		arg.Path,
		arg.SchemaVersion,
		arg.Schema,
	)
	var i HttpToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.DeploymentID,
		&i.Openapiv3DocumentID,
		&i.Name,
		&i.Summary,
		&i.Description,
		&i.Openapiv3Operation,
		&i.Tags,
		&i.ServerEnvVar,
		&i.Security,
		&i.HttpMethod,
		&i.Path,
		&i.SchemaVersion,
		&i.Schema,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getDeployment = `-- name: GetDeployment :one
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $1
    ORDER BY seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE deployments.id = $1 AND deployments.project_id = $2
`

type GetDeploymentParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetDeploymentRow struct {
	Deployment Deployment
	Status     string
}

func (q *Queries) GetDeployment(ctx context.Context, arg GetDeploymentParams) (GetDeploymentRow, error) {
	row := q.db.QueryRow(ctx, getDeployment, arg.ID, arg.ProjectID)
	var i GetDeploymentRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.Seq,
		&i.Deployment.UserID,
		&i.Deployment.ProjectID,
		&i.Deployment.OrganizationID,
		&i.Deployment.IdempotencyKey,
		&i.Deployment.GithubRepo,
		&i.Deployment.GithubPr,
		&i.Deployment.GithubSha,
		&i.Deployment.ExternalID,
		&i.Deployment.ExternalUrl,
		&i.Deployment.CreatedAt,
		&i.Deployment.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getDeploymentByIdempotencyKey = `-- name: GetDeploymentByIdempotencyKey :one
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $3
    ORDER BY seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE idempotency_key = $1
 AND project_id = $2
`

type GetDeploymentByIdempotencyKeyParams struct {
	IdempotencyKey string
	ProjectID      uuid.UUID
	ID             uuid.UUID
}

type GetDeploymentByIdempotencyKeyRow struct {
	Deployment Deployment
	Status     string
}

func (q *Queries) GetDeploymentByIdempotencyKey(ctx context.Context, arg GetDeploymentByIdempotencyKeyParams) (GetDeploymentByIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, getDeploymentByIdempotencyKey, arg.IdempotencyKey, arg.ProjectID, arg.ID)
	var i GetDeploymentByIdempotencyKeyRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.Seq,
		&i.Deployment.UserID,
		&i.Deployment.ProjectID,
		&i.Deployment.OrganizationID,
		&i.Deployment.IdempotencyKey,
		&i.Deployment.GithubRepo,
		&i.Deployment.GithubPr,
		&i.Deployment.GithubSha,
		&i.Deployment.ExternalID,
		&i.Deployment.ExternalUrl,
		&i.Deployment.CreatedAt,
		&i.Deployment.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getDeploymentOpenAPIv3 = `-- name: GetDeploymentOpenAPIv3 :many
SELECT id, deployment_id, asset_id, name, slug
FROM deployments_openapiv3_assets
WHERE deployment_id = $1
`

func (q *Queries) GetDeploymentOpenAPIv3(ctx context.Context, deploymentID uuid.UUID) ([]DeploymentsOpenapiv3Asset, error) {
	rows, err := q.db.Query(ctx, getDeploymentOpenAPIv3, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeploymentsOpenapiv3Asset
	for rows.Next() {
		var i DeploymentsOpenapiv3Asset
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.AssetID,
			&i.Name,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentWithAssets = `-- name: GetDeploymentWithAssets :many
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $1
    ORDER BY seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, deployments_openapiv3_assets.id, deployments_openapiv3_assets.deployment_id, deployments_openapiv3_assets.asset_id, deployments_openapiv3_assets.name, deployments_openapiv3_assets.slug, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN deployments_openapiv3_assets ON deployments.id = deployments_openapiv3_assets.deployment_id
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE deployments.id = $1 AND deployments.project_id = $2
`

type GetDeploymentWithAssetsParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetDeploymentWithAssetsRow struct {
	Deployment                Deployment
	DeploymentsOpenapiv3Asset DeploymentsOpenapiv3Asset
	Status                    string
}

func (q *Queries) GetDeploymentWithAssets(ctx context.Context, arg GetDeploymentWithAssetsParams) ([]GetDeploymentWithAssetsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentWithAssets, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentWithAssetsRow
	for rows.Next() {
		var i GetDeploymentWithAssetsRow
		if err := rows.Scan(
			&i.Deployment.ID,
			&i.Deployment.Seq,
			&i.Deployment.UserID,
			&i.Deployment.ProjectID,
			&i.Deployment.OrganizationID,
			&i.Deployment.IdempotencyKey,
			&i.Deployment.GithubRepo,
			&i.Deployment.GithubPr,
			&i.Deployment.GithubSha,
			&i.Deployment.ExternalID,
			&i.Deployment.ExternalUrl,
			&i.Deployment.CreatedAt,
			&i.Deployment.UpdatedAt,
			&i.DeploymentsOpenapiv3Asset.ID,
			&i.DeploymentsOpenapiv3Asset.DeploymentID,
			&i.DeploymentsOpenapiv3Asset.AssetID,
			&i.DeploymentsOpenapiv3Asset.Name,
			&i.DeploymentsOpenapiv3Asset.Slug,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeployments = `-- name: ListDeployments :many
SELECT 
  d.id,
  d.user_id,
  d.created_at,
  COUNT(doa.id) as asset_count
FROM deployments d
LEFT JOIN deployments_openapiv3_assets doa ON d.id = doa.deployment_id
WHERE
  d.project_id = $1
  AND d.id <= CASE 
    WHEN $2::uuid IS NOT NULL THEN $2::uuid
    ELSE (SELECT id FROM deployments WHERE project_id = $1 ORDER BY id DESC LIMIT 1)
  END
GROUP BY d.id
ORDER BY d.id DESC
LIMIT 51
`

type ListDeploymentsParams struct {
	ProjectID uuid.UUID
	Cursor    uuid.NullUUID
}

type ListDeploymentsRow struct {
	ID         uuid.UUID
	UserID     string
	CreatedAt  pgtype.Timestamptz
	AssetCount int64
}

func (q *Queries) ListDeployments(ctx context.Context, arg ListDeploymentsParams) ([]ListDeploymentsRow, error) {
	rows, err := q.db.Query(ctx, listDeployments, arg.ProjectID, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentsRow
	for rows.Next() {
		var i ListDeploymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.AssetCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logDeploymentEvent = `-- name: LogDeploymentEvent :exec
INSERT INTO deployment_logs (deployment_id, project_id, event, message)
VALUES ($1, $2, $3, $4)
`

type LogDeploymentEventParams struct {
	DeploymentID uuid.UUID
	ProjectID    uuid.UUID
	Event        string
	Message      string
}

func (q *Queries) LogDeploymentEvent(ctx context.Context, arg LogDeploymentEventParams) error {
	_, err := q.db.Exec(ctx, logDeploymentEvent,
		arg.DeploymentID,
		arg.ProjectID,
		arg.Event,
		arg.Message,
	)
	return err
}

const transitionDeployment = `-- name: TransitionDeployment :one
WITH status AS (
  INSERT INTO deployment_statuses (deployment_id , status)
  VALUES ($1, $2)
  RETURNING id, status
), 
log AS (
  INSERT INTO deployment_logs (deployment_id, project_id, event, message)
  VALUES ($1, $3, $4, $5)
  RETURNING id
)
SELECT status.id as status_id, status.status as status, log.id as log_id
FROM status, log
`

type TransitionDeploymentParams struct {
	DeploymentID uuid.UUID
	Status       string
	ProjectID    uuid.UUID
	Event        string
	Message      string
}

type TransitionDeploymentRow struct {
	StatusID uuid.UUID
	Status   string
	LogID    uuid.UUID
}

func (q *Queries) TransitionDeployment(ctx context.Context, arg TransitionDeploymentParams) (TransitionDeploymentRow, error) {
	row := q.db.QueryRow(ctx, transitionDeployment,
		arg.DeploymentID,
		arg.Status,
		arg.ProjectID,
		arg.Event,
		arg.Message,
	)
	var i TransitionDeploymentRow
	err := row.Scan(&i.StatusID, &i.Status, &i.LogID)
	return i, err
}
