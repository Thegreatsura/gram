// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEnvironment = `-- name: CreateEnvironment :one
INSERT INTO environments (
    organization_id,
    project_id,
    name,
    slug,
    description
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
`

type CreateEnvironmentParams struct {
	OrganizationID string
	ProjectID      uuid.UUID
	Name           string
	Slug           string
	Description    pgtype.Text
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) (Environment, error) {
	row := q.db.QueryRow(ctx, createEnvironment,
		arg.OrganizationID,
		arg.ProjectID,
		arg.Name,
		arg.Slug,
		arg.Description,
	)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createEnvironmentEntries = `-- name: CreateEnvironmentEntries :many
INSERT INTO environment_entries (
    environment_id,
    name,
    value
) 
/*
 Parameters:
 - environment_id: uuid
 - names: text[]
 - values: text[]
*/
VALUES (
    $1::uuid,
    unnest($2::text[]),
    unnest($3::text[])
)
RETURNING name, value, environment_id, created_at, updated_at
`

type CreateEnvironmentEntriesParams struct {
	EnvironmentID uuid.UUID
	Names         []string
	Values        []string
}

func (q *Queries) CreateEnvironmentEntries(ctx context.Context, arg CreateEnvironmentEntriesParams) ([]EnvironmentEntry, error) {
	rows, err := q.db.Query(ctx, createEnvironmentEntries, arg.EnvironmentID, arg.Names, arg.Values)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnvironmentEntry
	for rows.Next() {
		var i EnvironmentEntry
		if err := rows.Scan(
			&i.Name,
			&i.Value,
			&i.EnvironmentID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteEnvironment = `-- name: DeleteEnvironment :exec
WITH deleted_env AS (
    UPDATE environments
    SET deleted_at = now()
    WHERE environments.slug = $1 AND environments.project_id = $2 AND environments.deleted IS FALSE
    RETURNING slug, project_id
)
UPDATE toolsets
SET default_environment_slug = NULL
FROM deleted_env
WHERE toolsets.default_environment_slug = deleted_env.slug AND toolsets.project_id = deleted_env.project_id
`

type DeleteEnvironmentParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) DeleteEnvironment(ctx context.Context, arg DeleteEnvironmentParams) error {
	_, err := q.db.Exec(ctx, deleteEnvironment, arg.Slug, arg.ProjectID)
	return err
}

const deleteEnvironmentEntry = `-- name: DeleteEnvironmentEntry :exec
DELETE FROM environment_entries
WHERE environment_id = $1 AND name = $2
`

type DeleteEnvironmentEntryParams struct {
	EnvironmentID uuid.UUID
	Name          string
}

func (q *Queries) DeleteEnvironmentEntry(ctx context.Context, arg DeleteEnvironmentEntryParams) error {
	_, err := q.db.Exec(ctx, deleteEnvironmentEntry, arg.EnvironmentID, arg.Name)
	return err
}

const getEnvironmentByID = `-- name: GetEnvironmentByID :one
SELECT id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
FROM environments e
WHERE e.id = $1 AND e.project_id = $2 AND e.deleted IS FALSE
`

type GetEnvironmentByIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) GetEnvironmentByID(ctx context.Context, arg GetEnvironmentByIDParams) (Environment, error) {
	row := q.db.QueryRow(ctx, getEnvironmentByID, arg.ID, arg.ProjectID)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getEnvironmentBySlug = `-- name: GetEnvironmentBySlug :one
SELECT id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
FROM environments e
WHERE e.slug = $1 AND e.project_id = $2 AND e.deleted IS FALSE
`

type GetEnvironmentBySlugParams struct {
	Slug      string
	ProjectID uuid.UUID
}

// returns: GetEnvironmentByIDRow
func (q *Queries) GetEnvironmentBySlug(ctx context.Context, arg GetEnvironmentBySlugParams) (Environment, error) {
	row := q.db.QueryRow(ctx, getEnvironmentBySlug, arg.Slug, arg.ProjectID)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listEnvironmentEntries = `-- name: ListEnvironmentEntries :many
SELECT ee.name, ee.value, ee.environment_id, ee.created_at, ee.updated_at
FROM environment_entries ee
INNER JOIN environments e ON ee.environment_id = e.id
WHERE 
    e.project_id = $1 AND
    ee.environment_id = $2
ORDER BY ee.name ASC
`

type ListEnvironmentEntriesParams struct {
	ProjectID     uuid.UUID
	EnvironmentID uuid.UUID
}

func (q *Queries) ListEnvironmentEntries(ctx context.Context, arg ListEnvironmentEntriesParams) ([]EnvironmentEntry, error) {
	rows, err := q.db.Query(ctx, listEnvironmentEntries, arg.ProjectID, arg.EnvironmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnvironmentEntry
	for rows.Next() {
		var i EnvironmentEntry
		if err := rows.Scan(
			&i.Name,
			&i.Value,
			&i.EnvironmentID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvironments = `-- name: ListEnvironments :many
SELECT id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
FROM environments e
WHERE e.project_id = $1 AND e.deleted IS FALSE
ORDER BY e.created_at DESC
`

func (q *Queries) ListEnvironments(ctx context.Context, projectID uuid.UUID) ([]Environment, error) {
	rows, err := q.db.Query(ctx, listEnvironments, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Environment
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEnvironment = `-- name: UpdateEnvironment :one
UPDATE environments
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    updated_at = now()
WHERE slug = $3 AND project_id = $4 AND deleted IS FALSE
RETURNING id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
`

type UpdateEnvironmentParams struct {
	Name        string
	Description pgtype.Text
	Slug        string
	ProjectID   uuid.UUID
}

func (q *Queries) UpdateEnvironment(ctx context.Context, arg UpdateEnvironmentParams) (Environment, error) {
	row := q.db.QueryRow(ctx, updateEnvironment,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.ProjectID,
	)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const upsertEnvironmentEntry = `-- name: UpsertEnvironmentEntry :one
INSERT INTO environment_entries (environment_id, name, value, updated_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (environment_id, name) 
DO UPDATE SET 
    value = EXCLUDED.value,
    updated_at = now()
RETURNING name, value, environment_id, created_at, updated_at
`

type UpsertEnvironmentEntryParams struct {
	EnvironmentID uuid.UUID
	Name          string
	Value         string
}

func (q *Queries) UpsertEnvironmentEntry(ctx context.Context, arg UpsertEnvironmentEntryParams) (EnvironmentEntry, error) {
	row := q.db.QueryRow(ctx, upsertEnvironmentEntry, arg.EnvironmentID, arg.Name, arg.Value)
	var i EnvironmentEntry
	err := row.Scan(
		&i.Name,
		&i.Value,
		&i.EnvironmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
