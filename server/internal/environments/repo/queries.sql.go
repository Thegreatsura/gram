// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEnvironment = `-- name: CreateEnvironment :one
INSERT INTO environments (
    organization_id,
    project_id,
    name,
    slug,
    description
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted
`

type CreateEnvironmentParams struct {
	OrganizationID string
	ProjectID      uuid.UUID
	Name           string
	Slug           string
	Description    pgtype.Text
}

type CreateEnvironmentRow struct {
	ID             uuid.UUID
	OrganizationID string
	ProjectID      uuid.UUID
	Name           string
	Slug           string
	Description    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Deleted        bool
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) (CreateEnvironmentRow, error) {
	row := q.db.QueryRow(ctx, createEnvironment,
		arg.OrganizationID,
		arg.ProjectID,
		arg.Name,
		arg.Slug,
		arg.Description,
	)
	var i CreateEnvironmentRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const createEnvironmentEntries = `-- name: CreateEnvironmentEntries :many
INSERT INTO environment_entries (
    environment_id,
    name,
    value
) 
/*
 Parameters:
 - environment_id: uuid
 - names: text[]
 - values: text[]
*/
VALUES (
    $1::uuid,
    unnest($2::text[]),
    unnest($3::text[])
)
RETURNING name, value, environment_id, created_at, updated_at
`

type CreateEnvironmentEntriesParams struct {
	EnvironmentID uuid.UUID
	Names         []string
	Values        []string
}

func (q *Queries) CreateEnvironmentEntries(ctx context.Context, arg CreateEnvironmentEntriesParams) ([]EnvironmentEntry, error) {
	rows, err := q.db.Query(ctx, createEnvironmentEntries, arg.EnvironmentID, arg.Names, arg.Values)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnvironmentEntry
	for rows.Next() {
		var i EnvironmentEntry
		if err := rows.Scan(
			&i.Name,
			&i.Value,
			&i.EnvironmentID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteEnvironment = `-- name: DeleteEnvironment :exec
UPDATE environments
SET deleted_at = now()
WHERE slug = $1 AND project_id = $2 AND deleted IS FALSE
`

type DeleteEnvironmentParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) DeleteEnvironment(ctx context.Context, arg DeleteEnvironmentParams) error {
	_, err := q.db.Exec(ctx, deleteEnvironment, arg.Slug, arg.ProjectID)
	return err
}

const deleteEnvironmentEntry = `-- name: DeleteEnvironmentEntry :exec
DELETE FROM environment_entries
WHERE environment_id = $1 AND name = $2
`

type DeleteEnvironmentEntryParams struct {
	EnvironmentID uuid.UUID
	Name          string
}

func (q *Queries) DeleteEnvironmentEntry(ctx context.Context, arg DeleteEnvironmentEntryParams) error {
	_, err := q.db.Exec(ctx, deleteEnvironmentEntry, arg.EnvironmentID, arg.Name)
	return err
}

const getEnvironment = `-- name: GetEnvironment :one
SELECT 
    e.id,
    e.organization_id,
    e.project_id,
    e.name,
    e.slug,
    e.description,
    e.created_at,
    e.updated_at,
    e.deleted
FROM environments e
WHERE e.slug = $1 AND e.project_id = $2 AND e.deleted IS FALSE
`

type GetEnvironmentParams struct {
	Slug      string
	ProjectID uuid.UUID
}

type GetEnvironmentRow struct {
	ID             uuid.UUID
	OrganizationID string
	ProjectID      uuid.UUID
	Name           string
	Slug           string
	Description    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Deleted        bool
}

func (q *Queries) GetEnvironment(ctx context.Context, arg GetEnvironmentParams) (GetEnvironmentRow, error) {
	row := q.db.QueryRow(ctx, getEnvironment, arg.Slug, arg.ProjectID)
	var i GetEnvironmentRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const listEnvironmentEntries = `-- name: ListEnvironmentEntries :many
SELECT 
    ee.name as name,
    ee.value as value,
    ee.created_at as created_at,
    ee.updated_at as updated_at
FROM environment_entries ee
WHERE ee.environment_id = $1
ORDER BY ee.name ASC
`

type ListEnvironmentEntriesRow struct {
	Name      string
	Value     string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) ListEnvironmentEntries(ctx context.Context, environmentID uuid.UUID) ([]ListEnvironmentEntriesRow, error) {
	rows, err := q.db.Query(ctx, listEnvironmentEntries, environmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEnvironmentEntriesRow
	for rows.Next() {
		var i ListEnvironmentEntriesRow
		if err := rows.Scan(
			&i.Name,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvironments = `-- name: ListEnvironments :many
SELECT 
    e.id,
    e.organization_id,
    e.project_id,
    e.name,
    e.slug,
    e.description,
    e.created_at,
    e.updated_at,
    e.deleted
FROM environments e
WHERE e.project_id = $1 AND e.deleted IS FALSE
ORDER BY e.created_at DESC
`

type ListEnvironmentsRow struct {
	ID             uuid.UUID
	OrganizationID string
	ProjectID      uuid.UUID
	Name           string
	Slug           string
	Description    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Deleted        bool
}

func (q *Queries) ListEnvironments(ctx context.Context, projectID uuid.UUID) ([]ListEnvironmentsRow, error) {
	rows, err := q.db.Query(ctx, listEnvironments, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEnvironmentsRow
	for rows.Next() {
		var i ListEnvironmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEnvironment = `-- name: UpdateEnvironment :one
UPDATE environments
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    updated_at = now()
WHERE slug = $3 AND project_id = $4 AND deleted IS FALSE
RETURNING id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted
`

type UpdateEnvironmentParams struct {
	Name        string
	Description pgtype.Text
	Slug        string
	ProjectID   uuid.UUID
}

type UpdateEnvironmentRow struct {
	ID             uuid.UUID
	OrganizationID string
	ProjectID      uuid.UUID
	Name           string
	Slug           string
	Description    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Deleted        bool
}

func (q *Queries) UpdateEnvironment(ctx context.Context, arg UpdateEnvironmentParams) (UpdateEnvironmentRow, error) {
	row := q.db.QueryRow(ctx, updateEnvironment,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.ProjectID,
	)
	var i UpdateEnvironmentRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const upsertEnvironmentEntry = `-- name: UpsertEnvironmentEntry :one
INSERT INTO environment_entries (environment_id, name, value, updated_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (environment_id, name) 
DO UPDATE SET 
    value = EXCLUDED.value,
    updated_at = now()
RETURNING name, value, environment_id, created_at, updated_at
`

type UpsertEnvironmentEntryParams struct {
	EnvironmentID uuid.UUID
	Name          string
	Value         string
}

func (q *Queries) UpsertEnvironmentEntry(ctx context.Context, arg UpsertEnvironmentEntryParams) (EnvironmentEntry, error) {
	row := q.db.QueryRow(ctx, upsertEnvironmentEntry, arg.EnvironmentID, arg.Name, arg.Value)
	var i EnvironmentEntry
	err := row.Scan(
		&i.Name,
		&i.Value,
		&i.EnvironmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
