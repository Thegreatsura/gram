// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const listPackagesByVersionIDs = `-- name: ListPackagesByVersionIDs :many
SELECT packages.id as package_id, packages.name as package_name, package_versions.id, package_versions.package_id, package_versions.deployment_id, package_versions.visibility, package_versions.major, package_versions.minor, package_versions.patch, package_versions.prerelease, package_versions.build, package_versions.created_at, package_versions.updated_at, package_versions.deleted_at, package_versions.deleted
FROM package_versions
INNER JOIN packages ON package_versions.package_id = packages.id
WHERE package_versions.id = ANY($1::uuid[])
`

type ListPackagesByVersionIDsRow struct {
	PackageID      uuid.UUID
	PackageName    string
	PackageVersion PackageVersion
}

func (q *Queries) ListPackagesByVersionIDs(ctx context.Context, ids []uuid.UUID) ([]ListPackagesByVersionIDsRow, error) {
	rows, err := q.db.Query(ctx, listPackagesByVersionIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPackagesByVersionIDsRow
	for rows.Next() {
		var i ListPackagesByVersionIDsRow
		if err := rows.Scan(
			&i.PackageID,
			&i.PackageName,
			&i.PackageVersion.ID,
			&i.PackageVersion.PackageID,
			&i.PackageVersion.DeploymentID,
			&i.PackageVersion.Visibility,
			&i.PackageVersion.Major,
			&i.PackageVersion.Minor,
			&i.PackageVersion.Patch,
			&i.PackageVersion.Prerelease,
			&i.PackageVersion.Build,
			&i.PackageVersion.CreatedAt,
			&i.PackageVersion.UpdatedAt,
			&i.PackageVersion.DeletedAt,
			&i.PackageVersion.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const peekLatestPackageVersionByName = `-- name: PeekLatestPackageVersionByName :one
SELECT packages.id as package_id, package_versions.id as package_version_id
FROM packages
INNER JOIN package_versions ON packages.id = package_versions.package_id
WHERE packages.name = $1
ORDER BY package_versions.id DESC
LIMIT 1
`

type PeekLatestPackageVersionByNameRow struct {
	PackageID        uuid.UUID
	PackageVersionID uuid.UUID
}

func (q *Queries) PeekLatestPackageVersionByName(ctx context.Context, name string) (PeekLatestPackageVersionByNameRow, error) {
	row := q.db.QueryRow(ctx, peekLatestPackageVersionByName, name)
	var i PeekLatestPackageVersionByNameRow
	err := row.Scan(&i.PackageID, &i.PackageVersionID)
	return i, err
}

const peekPackageByNameAndVersion = `-- name: PeekPackageByNameAndVersion :one
SELECT packages.id as package_id, package_versions.id as package_version_id
FROM packages
INNER JOIN package_versions ON packages.id = package_versions.package_id
WHERE packages.name = $1
  AND package_versions.major = $2
  AND package_versions.minor = $3
  AND package_versions.patch = $4
  AND package_versions.prerelease = $5
  AND package_versions.build = $6
LIMIT 1
`

type PeekPackageByNameAndVersionParams struct {
	Name       string
	Major      int16
	Minor      int16
	Patch      int16
	Prerelease pgtype.Text
	Build      pgtype.Text
}

type PeekPackageByNameAndVersionRow struct {
	PackageID        uuid.UUID
	PackageVersionID uuid.UUID
}

func (q *Queries) PeekPackageByNameAndVersion(ctx context.Context, arg PeekPackageByNameAndVersionParams) (PeekPackageByNameAndVersionRow, error) {
	row := q.db.QueryRow(ctx, peekPackageByNameAndVersion,
		arg.Name,
		arg.Major,
		arg.Minor,
		arg.Patch,
		arg.Prerelease,
		arg.Build,
	)
	var i PeekPackageByNameAndVersionRow
	err := row.Scan(&i.PackageID, &i.PackageVersionID)
	return i, err
}
