package cache

import (
	"context"
	"errors"
	"fmt"
	"os"
	"time"

	redisCache "github.com/go-redis/cache/v8"
	"github.com/go-redis/redis/v8"
	"github.com/google/uuid"
	"github.com/speakeasy-api/gram/internal/log"
	"go.uber.org/zap"
)

type Cache[T Cacheable[T]] struct {
	rdb       *redis.Client
	cache     *redisCache.Cache
	keySuffix string
	ttl       time.Duration
}

// Cacheable - when implementing this, make sure all data fields you want stored in the cache are exported (capitalized).
type Cacheable[T any] interface {
	CacheKey() string
	AdditionalCacheKeys() []string
}

/*
WithCache is a decorator that will cache the result of the decorated function.
The cache key is generated by calling the CacheKey() method on the first argument.
The passed function is only called if the cache is empty, or cannot be reached.
*/
func (d *Cache[T]) WithCache(ctx context.Context, cacheObject T, f func(ctx context.Context) (T, error)) (T, error) { //nolint:nolintlint,ireturn
	return d.WithRawCache(ctx, cacheObject.CacheKey(), f)
}

func (d *Cache[T]) WithRawCache(ctx context.Context, key string, f func(ctx context.Context) (T, error)) (T, error) { //nolint:nolintlint,ireturn
	if d.cache == nil {
		return f(ctx)
	}

	var returnObj T

	invoked := false

	err := d.cache.Once(&redisCache.Item{
		Ctx:   ctx,
		Key:   d.fullKey(key),
		Value: &returnObj,
		TTL:   d.ttl,
		Do: func(item *redisCache.Item) (interface{}, error) {
			invoked = true
			return f(ctx)
		},
	})

	// If the cache is down, we still want to try and execute the function
	if err != nil && !invoked {
		return f(ctx)
	}

	return returnObj, err
}

func (d *Cache[T]) fullKey(key string) string {
	return key + ":" + d.keySuffix
}

func (d *Cache[T]) Delete(ctx context.Context, obj T) error {
	if d.cache == nil {
		return nil
	}

	cacheKey := d.fullKey(obj.CacheKey())
	log.From(ctx).Info("invalidating cache", zap.String("cache key", cacheKey))
	err := d.cache.Delete(ctx, cacheKey)
	if err != nil {
		return err
	}
	for _, key := range obj.AdditionalCacheKeys() {
		err := d.cache.Delete(ctx, d.fullKey(key))
		if err != nil {
			return err
		}
	}
	return nil
}

func (d *Cache[T]) Get(context context.Context, key string) (T, error) { //nolint:nolintlint,ireturn
	if d.cache == nil {
		return *new(T), redisCache.ErrCacheMiss
	}

	var returnObj T

	err := d.cache.Get(context, d.fullKey(key), &returnObj)

	return returnObj, err
}

func (d *Cache[T]) Store(context context.Context, obj T) error {
	if d.cache == nil {
		//nolint:goerr113
		return errors.New("cache is not configured")
	}

	err := d.cache.Set(&redisCache.Item{
		Ctx:   context,
		Key:   d.fullKey(obj.CacheKey()),
		Value: obj,
		TTL:   d.ttl,
	})
	if err != nil {
		return err
	}
	for _, key := range obj.AdditionalCacheKeys() {
		err := d.cache.Set(&redisCache.Item{
			Ctx:   context,
			Key:   d.fullKey(key),
			Value: obj,
			TTL:   d.ttl,
		})
		if err != nil {
			return err
		}
	}
	return nil
}

func New[T Cacheable[T]](ttl time.Duration) Cache[T] {
	// TODO: Stable server versions
	var serverVersion string
	var redisAddr string
	var redisPassword string
	if os.Getenv("GRAM_ENVIRONMENT") == "local" {
		serverVersion = uuid.NewString()
		redisAddr = fmt.Sprintf("localhost:%s", os.Getenv("CACHE_PORT"))
		redisPassword = "xi9XILbY"
	}

	rdb := redis.NewClient(&redis.Options{
		Addr:         redisAddr,
		Password:     redisPassword,
		DB:           0, // we always use default DB
		DialTimeout:  1 * time.Second,
		ReadTimeout:  300 * time.Millisecond,
		WriteTimeout: 1 * time.Second,
	})

	if err := rdb.Ping(context.Background()).Err(); err != nil {
		fmt.Println("Redis connection failed: %v", err)
		panic(err)
	}

	cache := redisCache.New(&redisCache.Options{
		Redis: rdb,
	})

	return Cache[T]{rdb: rdb, cache: cache, ttl: ttl, keySuffix: serverVersion}
}
