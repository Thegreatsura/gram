package cache

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"time"

	redisCache "github.com/go-redis/cache/v8"
	"github.com/go-redis/redis/v8"
)

type Cache[T Cacheable[T]] struct {
	logger    *slog.Logger
	rdb       *redis.Client
	cache     *redisCache.Cache
	keySuffix string
	ttl       time.Duration
}

// Cacheable - when implementing this, make sure all data fields you want stored in the cache are exported (capitalized).
type Cacheable[T any] interface {
	CacheKey() string
	AdditionalCacheKeys() []string
}

/*
WithCache is a decorator that will cache the result of the decorated function.
The cache key is generated by calling the CacheKey() method on the first argument.
The passed function is only called if the cache is empty, or cannot be reached.
*/
func (d *Cache[T]) WithCache(ctx context.Context, cacheObject T, f func(ctx context.Context) (T, error)) (T, error) { //nolint:nolintlint,ireturn
	return d.WithRawCache(ctx, cacheObject.CacheKey(), f)
}

func (d *Cache[T]) WithRawCache(ctx context.Context, key string, f func(ctx context.Context) (T, error)) (T, error) { //nolint:nolintlint,ireturn
	if d.cache == nil {
		return f(ctx)
	}

	var returnObj T

	invoked := false

	err := d.cache.Once(&redisCache.Item{
		Ctx:   ctx,
		Key:   d.fullKey(key),
		Value: &returnObj,
		TTL:   d.ttl,
		Do: func(item *redisCache.Item) (interface{}, error) {
			invoked = true
			return f(ctx)
		},
	})

	// If the cache is down, we still want to try and execute the function
	if err != nil && !invoked {
		return f(ctx)
	}

	return returnObj, err
}

func (d *Cache[T]) fullKey(key string) string {
	return key + ":" + d.keySuffix
}

func (d *Cache[T]) Delete(ctx context.Context, obj T) error {
	if d.cache == nil {
		return nil
	}

	cacheKey := d.fullKey(obj.CacheKey())
	d.logger.InfoContext(ctx, "invalidating cache", slog.String("key", cacheKey))
	err := d.cache.Delete(ctx, cacheKey)
	if err != nil {
		return err
	}
	for _, key := range obj.AdditionalCacheKeys() {
		err := d.cache.Delete(ctx, d.fullKey(key))
		if err != nil {
			return err
		}
	}
	return nil
}

func (d *Cache[T]) Get(context context.Context, key string) (T, error) { //nolint:nolintlint,ireturn
	if d.cache == nil {
		return *new(T), redisCache.ErrCacheMiss
	}

	var returnObj T

	err := d.cache.Get(context, d.fullKey(key), &returnObj)

	return returnObj, err
}

func (d *Cache[T]) Store(context context.Context, obj T) error {
	if d.cache == nil {
		//nolint:goerr113
		return errors.New("cache is not configured")
	}

	err := d.cache.Set(&redisCache.Item{
		Ctx:   context,
		Key:   d.fullKey(obj.CacheKey()),
		Value: obj,
		TTL:   d.ttl,
	})
	if err != nil {
		return err
	}
	for _, key := range obj.AdditionalCacheKeys() {
		err := d.cache.Set(&redisCache.Item{
			Ctx:   context,
			Key:   d.fullKey(key),
			Value: obj,
			TTL:   d.ttl,
		})
		if err != nil {
			return err
		}
	}
	return nil
}

// Update Updates an object in cache preserving the existing TTL
func (d *Cache[T]) Update(ctx context.Context, obj T) error {
	if d.cache == nil {
		return errors.New("cache is not configured")
	}

	updateKey := func(key string) error {
		fullKey := d.fullKey(key)

		ttl, err := d.rdb.TTL(ctx, fullKey).Result()
		if err != nil {
			return fmt.Errorf("failed to fetch TTL for key %s: %w", fullKey, err)
		}

		if ttl <= 0 {
			return fmt.Errorf("failed to fetch TTL for key %s", fullKey)
		}

		err = d.cache.Set(&redisCache.Item{
			Ctx:   ctx,
			Key:   fullKey,
			Value: obj,
			TTL:   ttl,
		})
		if err != nil {
			return fmt.Errorf("failed to update key %s: %w", fullKey, err)
		}
		return nil
	}

	// Update primary key
	if err := updateKey(obj.CacheKey()); err != nil {
		return err
	}

	// Update additional keys
	for _, key := range obj.AdditionalCacheKeys() {
		if err := updateKey(key); err != nil {
			return err
		}
	}

	return nil
}

func New[T Cacheable[T]](logger *slog.Logger, ttl time.Duration) Cache[T] {
	// TODO: Stable server versions
	var serverVersion string
	var redisAddr string
	var redisPassword string
	if os.Getenv("GRAM_ENVIRONMENT") == "local" {
		serverVersion = "gram-local"
		redisAddr = fmt.Sprintf("localhost:%s", os.Getenv("CACHE_PORT"))
		redisPassword = "xi9XILbY"
	}

	rdb := redis.NewClient(&redis.Options{
		Addr:         redisAddr,
		Password:     redisPassword,
		DB:           0, // we always use default DB
		DialTimeout:  1 * time.Second,
		ReadTimeout:  300 * time.Millisecond,
		WriteTimeout: 1 * time.Second,
	})

	if err := rdb.Ping(context.Background()).Err(); err != nil {
		logger.Error("redis connection failed", slog.String("error", err.Error()))
		panic(err)
	}

	cache := redisCache.New(&redisCache.Options{
		Redis: rdb,
	})

	return Cache[T]{logger: logger, rdb: rdb, cache: cache, ttl: ttl, keySuffix: serverVersion}
}
