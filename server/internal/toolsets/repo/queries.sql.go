// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createToolset = `-- name: CreateToolset :one
INSERT INTO toolsets (
    organization_id
  , project_id
  , name
  , slug
  , description
  , http_tool_names
  , default_environment_slug
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , COALESCE($6::text[], '{}'::text[])
  , $7
)
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, created_at, updated_at, deleted_at, deleted
`

type CreateToolsetParams struct {
	OrganizationID         string
	ProjectID              uuid.UUID
	Name                   string
	Slug                   string
	Description            pgtype.Text
	HttpToolNames          []string
	DefaultEnvironmentSlug pgtype.Text
}

func (q *Queries) CreateToolset(ctx context.Context, arg CreateToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, createToolset,
		arg.OrganizationID,
		arg.ProjectID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.HttpToolNames,
		arg.DefaultEnvironmentSlug,
	)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteToolset = `-- name: DeleteToolset :exec
UPDATE toolsets
SET deleted_at = clock_timestamp()
WHERE slug = $1
  AND project_id = $2 AND deleted IS FALSE
`

type DeleteToolsetParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) DeleteToolset(ctx context.Context, arg DeleteToolsetParams) error {
	_, err := q.db.Exec(ctx, deleteToolset, arg.Slug, arg.ProjectID)
	return err
}

const getHTTPSecurityDefinitions = `-- name: GetHTTPSecurityDefinitions :many
SELECT id, key, deployment_id, type, name, in_placement, scheme, bearer_format, env_variables, created_at, updated_at, deleted_at, deleted
FROM http_security
WHERE key = ANY($1::TEXT[]) AND deployment_id = ANY($2::UUID[])
`

type GetHTTPSecurityDefinitionsParams struct {
	SecurityKeys  []string
	DeploymentIds []uuid.UUID
}

func (q *Queries) GetHTTPSecurityDefinitions(ctx context.Context, arg GetHTTPSecurityDefinitionsParams) ([]HttpSecurity, error) {
	rows, err := q.db.Query(ctx, getHTTPSecurityDefinitions, arg.SecurityKeys, arg.DeploymentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HttpSecurity
	for rows.Next() {
		var i HttpSecurity
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DeploymentID,
			&i.Type,
			&i.Name,
			&i.InPlacement,
			&i.Scheme,
			&i.BearerFormat,
			&i.EnvVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolset = `-- name: GetToolset :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE slug = $1 AND project_id = $2 AND deleted IS FALSE
`

type GetToolsetParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) GetToolset(ctx context.Context, arg GetToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolset, arg.Slug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetByMcpSlug = `-- name: GetToolsetByMcpSlug :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE mcp_slug = $1
  AND deleted IS FALSE
`

func (q *Queries) GetToolsetByMcpSlug(ctx context.Context, mcpSlug pgtype.Text) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolsetByMcpSlug, mcpSlug)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listToolsetsByProject = `-- name: ListToolsetsByProject :many
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE project_id = $1
  AND deleted IS FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListToolsetsByProject(ctx context.Context, projectID uuid.UUID) ([]Toolset, error) {
	rows, err := q.db.Query(ctx, listToolsetsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Toolset
	for rows.Next() {
		var i Toolset
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.DefaultEnvironmentSlug,
			&i.HttpToolNames,
			&i.McpSlug,
			&i.McpIsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToolset = `-- name: UpdateToolset :one
UPDATE toolsets
SET 
    name = COALESCE($1, name)
  , description = COALESCE($2, description)
  , http_tool_names = COALESCE($3::text[], http_tool_names)
  , default_environment_slug = COALESCE($4, default_environment_slug)
  , mcp_slug = COALESCE($5, mcp_slug)
  , mcp_is_public = COALESCE($6, mcp_is_public)
  , updated_at = clock_timestamp()
WHERE slug = $7 AND project_id = $8
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, created_at, updated_at, deleted_at, deleted
`

type UpdateToolsetParams struct {
	Name                   string
	Description            pgtype.Text
	HttpToolNames          []string
	DefaultEnvironmentSlug pgtype.Text
	McpSlug                pgtype.Text
	McpIsPublic            bool
	Slug                   string
	ProjectID              uuid.UUID
}

func (q *Queries) UpdateToolset(ctx context.Context, arg UpdateToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, updateToolset,
		arg.Name,
		arg.Description,
		arg.HttpToolNames,
		arg.DefaultEnvironmentSlug,
		arg.McpSlug,
		arg.McpIsPublic,
		arg.Slug,
		arg.ProjectID,
	)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}
