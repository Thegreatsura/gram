// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createToolset = `-- name: CreateToolset :one
INSERT INTO toolsets (
    organization_id
  , project_id
  , name
  , slug
  , description
  , http_tool_ids
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , NULLIF($6::uuid[], '{}'::uuid[])
)
RETURNING 
    id
  , organization_id
  , project_id
  , name
  , slug
  , description
  , http_tool_ids
  , created_at
  , updated_at
  , deleted_at
  , deleted
`

type CreateToolsetParams struct {
	OrganizationID uuid.UUID
	ProjectID      uuid.UUID
	Name           string
	Slug           string
	Description    pgtype.Text
	HttpToolIds    []uuid.UUID
}

func (q *Queries) CreateToolset(ctx context.Context, arg CreateToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, createToolset,
		arg.OrganizationID,
		arg.ProjectID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.HttpToolIds,
	)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.HttpToolIds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteToolset = `-- name: DeleteToolset :exec
UPDATE toolsets
SET deleted_at = clock_timestamp()
WHERE id = $1
`

func (q *Queries) DeleteToolset(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteToolset, id)
	return err
}

const getHTTPToolDefinitions = `-- name: GetHTTPToolDefinitions :many
SELECT 
    id
  , organization_id
  , project_id
  , name
  , description
  , server_env_var
  , security_type
  , bearer_env_var
  , apikey_env_var
  , username_env_var
  , password_env_var
  , http_method
  , path
  , headers_schema
  , queries_schema
  , pathparams_schema
  , body_schema
  , created_at
  , updated_at
  , deleted_at
  , deleted
FROM http_tool_definitions
WHERE id = ANY($1::uuid[])
  AND deleted_at IS NULL
`

func (q *Queries) GetHTTPToolDefinitions(ctx context.Context, ids []uuid.UUID) ([]HttpToolDefinition, error) {
	rows, err := q.db.Query(ctx, getHTTPToolDefinitions, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HttpToolDefinition
	for rows.Next() {
		var i HttpToolDefinition
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.ServerEnvVar,
			&i.SecurityType,
			&i.BearerEnvVar,
			&i.ApikeyEnvVar,
			&i.UsernameEnvVar,
			&i.PasswordEnvVar,
			&i.HttpMethod,
			&i.Path,
			&i.HeadersSchema,
			&i.QueriesSchema,
			&i.PathparamsSchema,
			&i.BodySchema,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolset = `-- name: GetToolset :one
SELECT 
    id
  , organization_id
  , project_id
  , name
  , slug
  , description
  , http_tool_ids
  , created_at
  , updated_at
  , deleted_at
  , deleted
FROM toolsets
WHERE id = $1
`

func (q *Queries) GetToolset(ctx context.Context, id uuid.UUID) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolset, id)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.HttpToolIds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listToolsetsByProject = `-- name: ListToolsetsByProject :many
SELECT 
    id
  , organization_id
  , project_id
  , name
  , slug
  , description
  , http_tool_ids
  , created_at
  , updated_at
  , deleted_at
  , deleted
FROM toolsets
WHERE project_id = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListToolsetsByProject(ctx context.Context, projectID uuid.UUID) ([]Toolset, error) {
	rows, err := q.db.Query(ctx, listToolsetsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Toolset
	for rows.Next() {
		var i Toolset
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.HttpToolIds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToolset = `-- name: UpdateToolset :one
UPDATE toolsets
SET 
    name = COALESCE($1, name)
  , description = COALESCE($2, description)
  , http_tool_ids = COALESCE(NULLIF($3::uuid[], '{}'::uuid[]), http_tool_ids)
  , updated_at = clock_timestamp()
WHERE id = $4
RETURNING 
    id
  , organization_id
  , project_id
  , name
  , slug
  , description
  , http_tool_ids
  , created_at
  , updated_at
  , deleted_at
  , deleted
`

type UpdateToolsetParams struct {
	Name        string
	Description pgtype.Text
	HttpToolIds []uuid.UUID
	ID          uuid.UUID
}

func (q *Queries) UpdateToolset(ctx context.Context, arg UpdateToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, updateToolset,
		arg.Name,
		arg.Description,
		arg.HttpToolIds,
		arg.ID,
	)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.HttpToolIds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}
