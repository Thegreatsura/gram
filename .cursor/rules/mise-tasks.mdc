---
description: Rules for writing mise tasks
globs: .mise-tasks/**/*.sh
alwaysApply: false
---
# Task Configuration

- This is how you write [mise](mdc:https:/mise.jdx.dev) tasks using bash.
- This is a list of all the relevant configuration options available in shell scripts.
- It is not an exhaustive list. All options can be found [here](mdc:https:/mise.jdx.dev/tasks/task-configuration.html).
- Tasks options MUST come right after the initial shebang line 
- Each task option must be listed one a separate line and MUST follow the form `#MISE <option>=<value>`.
- All shell scripts MUST start with `#!/usr/bin/env bash` followed by a blank line without exception.

<detail open><summary>Example</summary>

```sh
#!/usr/bin/env bash

#MISE description="An example task description"
#MISE dir="{{ config_root }}/example"

set -e
echo "Hello world"
```

</detail>

## Task options

### `description`

- **Type**: `string`

A description of the task. This is used in (among other places) the help output, completions, `mise run` (without arguments), and `mise tasks`.

<detail open><summary>Example</summary>

```sh
#MISE description="Useful description here"
```

</detail>

### `depends`

- **Type**: `string | string[]`

Tasks that must be run before this task. This is a list of task names or aliases. Arguments can be passed to the task, e.g.: `depends = ["build --release"]`. If multiple tasks have the same dependency, that dependency will only be run once. mise will run whatever it can in parallel (up to `--jobs`) through the use of `depends` and related properties.

<detail open><summary>Example</summary>

```sh
#MISE depends=["test","build:go","lint:*"]
```

</detail>

### `env`

- **Type**: `{ [key]: string | int | bool }`

Environment variables specific to this task. These will not be passed to `depends` tasks.

<detail open><summary>Example</summary>

```sh
#MISE env.TEST_ENV_VAR="ABC"
```

</detail>

### `dir`

- **Type**: `string`
- **Default**: <code v-pre>"{{ config_root }}"</code> - the directory containing [mise.toml](mdc:mise.toml).

The directory to run the task from. The most common way this is used is when you want the task to execute in the user's current directory:

<detail open><summary>Example</summary>

```sh
#MISE dir="{{ config_root }}/server"
```

</detail>

### `hide`

- **Type**: `bool`
- **Default**: `false`

Hide the task from help, completion, and other output like `mise tasks`. Useful for deprecated or internal tasks you don't want others to easily see.

<detail open><summary>Example</summary>

```sh
#MISE hide=true
```

</detail>

### `confirm`

- **Type**: `string`

A message to show before running the task. This is useful for tasks that are destructive or take a long time to run. The user will be prompted to confirm before the task is run.

<detail open><summary>Example</summary>

```sh
#MISE confirm="Are you sure you want to cut a release?"
```

</detail>

### `sources`

- **Type**: `string | string[]`

Files or directories that this task uses as input, if this and `outputs` is defined, mise will skip executing tasks where the modification time of the oldest output file is newer than the modification time of the newest source file. This is useful for tasks that are expensive to run and only need to be run when their inputs change.

The task itself will be automatically added as a source, so if you edit the definition that will also cause the task to be run.

This is also used in `mise watch` to know which files/directories to watch.

This can be specified with relative paths to the config file and/or with glob patterns, e.g.: `src/**/*.rs`. Ensure you don't go crazy with adding a ton of files in a glob thoughâ€”mise has to scan each and every one to check the timestamp.

<detail open><summary>Example</summary>

```sh
#MISE sources=["go.mod", "go.sum", "**/*.{go,sql}"]
```

</detail>

### `outputs`

- **Type**: `string | string[] | { auto = true }`

The counterpart to `sources`, these are the files or directories that the task will create/modify after it executes.

`auto = true` is an alternative to specifying output files manually. In that case, mise will touch an internally tracked file based on the hash of the task definition (stored in `~/.local/state/mise/task-outputs/<hash>` if you're curious). This is useful if you want `mise run` to execute when sources change but don't want to have to manually `touch` a file for `sources` to work.

<detail open><summary>Example</summary>

```sh
#MISE sources=["Cargo.toml", "src/**/*.rs"]
#MISE outputs={ auto = true }
```

</detail>

### `quiet`

- **Type**: `bool`
- **Default**: `false`

Suppress mise's output for the task such as showing the command that is run, e.g.: `[build] $ cargo build`. When this is set, mise won't show any output other than what the script itself outputs. If you'd also like to hide even the output that the task emits, use `silent`.

<detail open><summary>Example</summary>

```sh
#MISE quiet=true
```

</detail>

### `silent`

- **Type**: `bool | "stdout" | "stderr"`
- **Default**: `false`

Suppress all output from the task. If set to `"stdout"` or `"stderr"`, only that stream will be suppressed.

<detail open><summary>Example</summary>

```sh
#MISE silent=true
```

</detail>

## `redactions` <Badge type="warning" text="experimental" />

- **Type**: `string[]`

Redactions are a way to hide sensitive information from the output of tasks. This is useful for things like API keys, passwords, or other sensitive information that you don't want to accidentally leak in logs or other output.

A list of environment variables to redact from the output.

<detail open><summary>Example</summary>

```sh
#MISE redactions=["API_KEY", "PASSWORD"]
```

</detail>

Running the above task will output `echo [redacted]` instead.

You can also specify these as a glob pattern, e.g.: `redactions.env = ["SECRETS_*"]`.
